---
title: 线程1
date: 2019-11-24 2:38:32
tags:
  - 线程
---

#### 应用程序，进程，线程概念

应用程序：可执行的软件，QQ，微信，在一个应用程序中，都会有进程

进程：正在运行的程序，是多个线程的集合，进程中有多个不同的执行路径，在进程中，一定有一个主线程main

线程：正在独立运行的一条执行路径，一个执行顺序

#### 创建线程的方式：

1. 使用继承Thread类方式，继承Thread类重写run方法（run方法是线程需要执行的任务或需要执行的代码）
2. 使用Runnable接口方式
3. 使用匿名内部类方式
4. callable
5. 使用线程池创建线程

Thread.currentThread()：拿到当前线程

获取子线程id：继承Thread类后，调用getId()方法，子线程id是唯一的，不会重复

获取主线程id：Thread.currentThread().getId()

任何一个程序肯定有一个主线程

#### 给子线程命名：
```
子类 子类名=new 子类();
Thread thread=new THread(子类名,"线程名称");
```

Thread.sleep(1000);：延迟1秒

Thread类的stop()方法：不建议使用，不安全，执行到此代码时，无论之后是什么代码，都会当即中断，抛异常，很不靠谱

继承Thread类时，调用stop()方法：stop();

继承Runnable接口时，调用stop()方法：Thread.currentThread().stop();

创建线程用继承方式较好还是接口方式较好？使用接口方式较好；开发都是面向接口编程；单继承，多实现(接口)

单线程：同步（代码从上往下进行执行）

多线程：异步

守护线程：和main相关，gc线程

守护线程的一个特征：和主线程一起销毁

非守护线程：和主线程互不影响，用户线程

用户线程：用户自己创建的线程，如果主线程停止掉，不会影响用户线程

thread.setDaemon(true);：设置该线程为守护线程，和主线程一起销毁

#### 多线程的运行状态：
1. 新建
2. 准备
3. 运行
4. 休眠
5. 停止(阻塞)

thread.join();：当前线程让给另一个线程thread先执行完毕再执行

#### 线程安全问题：

当多个线程共享同一个全局变量或静态变量时，写的时候，可能会受到其他线程的干扰，导致数据有问题，这种现象叫做线程安全问题；读的时候，不会产生线程安全问题

局部变量不共享，所以不会出现线程安全问题

#### 线程如何实现同步（同步：保证数据的原子性）

可使用：

1. synchroized--自动档
2. lock--jdk1.5并发包--手动

#### 加锁的必须条件：

1. 必须要有两个或两个以上的线程
2. 必须是多个线程用同一把锁
3. 保证同步中只有一个线程在执行

#### synchroized原理：

1. 有一个线程已经拿到锁，
2. 代码执行完毕或程序抛出异常都会被释放掉
3. 锁已经被释放掉的话，其他线程就开始抢锁
4. 锁的资源竞争

好处：解决线程安全问题

缺点：效率非常低（因为有锁的资源竞争）

同步函数：在方法上修饰synchroized；同步函数分为静态和非静态的，非静态同步函数采用的是this锁，静态函数采用的是当前类的字节码文件，也就是（类.class）

一个线程使用同步函数，另一个线程是同步代码块this，能同步

一个线程使用同步函数，另一个线程是同步代码块非this，不能同步

一个线程使用同步函数，另一个线程是静态同步函数，不能同步，因为同步函数使用this锁，静态同步函数使用当前字节码文件

当一个变量被static修饰的话存放在永久区，当class文件被加载的时候就会被初始化

分布式锁，高并发和jvm是没有任何关系的

全局变量和静态变量一样，都是共享的

多线程死锁

死锁的产生：同步中嵌套同步，互不释放

